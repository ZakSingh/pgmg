create table cart_listing (
    account_id            int         not null references account on delete cascade,
    item_id               int         not null references listing on delete cascade,
    quantity              int         not null,
    selected_for_checkout bool        not null default true,

    created_at            timestamptz not null default now(),
    updated_at            timestamptz not null default now(),

    primary key (account_id, item_id)
);

comment on table cart_listing is $$
    A listing in an account's cart.
$$;

-- Performance index for item-based cart lookups
create index idx_cart_listing_item_account on cart_listing (item_id, account_id);
comment on index idx_cart_listing_item_account is $$
    Optimizes EXISTS queries in api.get_product that check if an item is in the user's cart.
    Complements the primary key index (account_id, item_id) for the opposite access pattern.
$$;


create table checkout (
    checkout_id      int generated by default as identity primary key,
    account_id       int         not null references account on delete cascade,
    delivery_contact contact,

    created_at       timestamptz not null default now(),
    updated_at       timestamptz not null default now()
);

comment on table checkout is $$
    A checkout session. Created every time a user clicks 'checkout' in their cart.
$$;

-- IMPORTANT: Keep dimension and weight constraints consistent with listing and parcel_template tables
create table parcel (
    parcel_id               int generated by default as identity primary key,

    length                  numeric(10, 2) not null
        constraint length_gt_zero check (length > 0),
    width                   numeric(10, 2) not null
        constraint width_gt_zero check (width > 0),
    height                  numeric(10, 2) not null
        constraint height_gt_zero check (height > 0),
    dimensions_unit         distance_unit  not null,
    weight                  numeric(10, 2) not null
        constraint weight_gt_zero check (weight > 0),
    weight_unit             mass_unit      not null,

    -- Unit-aware constraints for dimensions (max 50 inches per dimension)
    constraint parcel_length_max check (
        (dimensions_unit = 'in' and length <= 50) or
        (dimensions_unit = 'ft' and length <= 4.17) or
        (dimensions_unit = 'cm' and length <= 127) or
        (dimensions_unit = 'mm' and length <= 1270) or
        (dimensions_unit = 'm' and length <= 1.27)
        ),
    constraint parcel_width_max check (
        (dimensions_unit = 'in' and width <= 50) or
        (dimensions_unit = 'ft' and width <= 4.17) or
        (dimensions_unit = 'cm' and width <= 127) or
        (dimensions_unit = 'mm' and width <= 1270) or
        (dimensions_unit = 'm' and width <= 1.27)
        ),
    constraint parcel_height_max check (
        (dimensions_unit = 'in' and height <= 50) or
        (dimensions_unit = 'ft' and height <= 4.17) or
        (dimensions_unit = 'cm' and height <= 127) or
        (dimensions_unit = 'mm' and height <= 1270) or
        (dimensions_unit = 'm' and height <= 1.27)
        ),

    -- Unit-aware constraint for weight (max 20 lbs)
    constraint parcel_weight_max check (
        (weight_unit = 'g' and weight <= 9071.85) or
        (weight_unit = 'kg' and weight <= 9.07185) or
        (weight_unit = 'oz' and weight <= 320) or
        (weight_unit = 'lb' and weight <= 20)
        ),

    -- Track where the parcel dimensions came from
    -- If NULL, dimensions came from the listing; otherwise from the template
    dims_source_template_id int references parcel_template (parcel_template_id),

    -- Track if parcel contains externally shipped items
    is_shipped_externally   bool           not null default false,

    -- Track if seller pays for shipping on this parcel
    seller_pays_shipping    bool           not null default false,

    created_at              timestamptz    not null default now(),
    updated_at              timestamptz    not null default now()
);

comment on table parcel is $$
    A parcel contains one or more listings (via `line_item`).
    The dimensions and weight of the parcels in a checkout session are determined by a bin packing algorithm.
    This parcel data is used for calculating the shipping rate.
    
    The dims_source_template_id field indicates where the parcel dimensions came from:
    - If NULL: dimensions came from a single listing (when only one item in the parcel)
    - If NOT NULL: dimensions came from the referenced parcel template
$$;

create domain shippo_rate_id as text;

create domain shippo_transaction_id as text;

create table shipping_rate (
    shippo_rate_id shippo_rate_id primary key,
    parcel_id      int         not null references parcel on delete cascade,
    price          currency    not null,
    actual_cost    currency    not null,
    provider       text        not null,
    service_level  text        not null,
    duration_days  int,
    duration_terms text,

    is_selected    bool        not null default false,

    created_at     timestamptz not null default now(),
    updated_at     timestamptz
);

comment on table shipping_rate is $$
    Shipping rate for a parcel as calculated by Shippo. All the rates calculated
    by Shippo are saved here.
$$;

comment on column shipping_rate.price is $$
    Price shown to the buyer (may be $0 for free shipping items).
$$;

comment on column shipping_rate.actual_cost is $$
    Actual shipping cost that the platform pays to Shippo.
    For regular shipping, this equals price.
    For free shipping, this is the real cost while price is $0.
$$;

create unique index one_selected_shipping_rate_per_parcel
    on shipping_rate (parcel_id)
    where is_selected = true;

create table line_item (
    line_item_id int generated by default as identity primary key,
    checkout_id  int         not null references checkout on delete cascade,
    item_id      int         not null references listing on delete restrict,
    price        currency    not null,
    quantity     int         not null default 1 check (quantity > 0),

    parcel_id    int         not null references parcel on delete cascade,

    created_at   timestamptz not null default now(),
    updated_at   timestamptz not null default now()
);

comment on table line_item is $$
    Connects a listing in a transaction to the `parcel` it has been assigned to by the packing algorithm.
    A single listing can be split across multiple parcels if the total quantity doesn't fit in one box.
$$;

comment on column line_item.price is $$
    Save the listing price at time of checkout here for historical purposes. E.g. if we need to refund an item,
    we know exactly what price it was when the user bought it, even if the seller has changed the price since.
$$;

comment on column line_item.quantity is $$
    The number of units of this item in this parcel. The total quantity ordered may be split across multiple parcels.
$$;

create index idx_line_item_item_transaction on line_item (item_id)
    include (checkout_id, price, quantity);


-- listing_hold table removed - payment records now serve as inventory holds

create domain payment_intent_id as text;
create domain stripe_charge_id as text;
create domain payment_method_id as text;

create type transaction_status as enum (
    'pending',
    'method_attached', -- payment method has been cloned from platform to seller's connected account
    'intent_created', -- payment intent has been created successfully
    'ready_for_capture', -- ready to charge the user (items have been dispatched)
    'succeeded',
    'failed',
    'canceled',
    -- Failure reasons from old checkout_failure table:
    'failed_insufficient_stock',
    'failed_out_of_stock',
    'failed_seller_disabled',
    'failed_payment_error',
    'failed_unknown'
    );

create table transaction (
    checkout_id                int references checkout on delete restrict,
    seller_id                  int references seller on delete restrict,
    payment_intent_id          payment_intent_id unique,

    status                     transaction_status not null default 'pending',

    platform_payment_method_id payment_method_id  not null,
    connect_payment_method_id  payment_method_id,

    stripe_charge_id           stripe_charge_id,

    item_subtotal              currency           not null,
    shipping_subtotal          currency           not null,
    actual_shipping_cost       currency           not null,
    seller_fee                 currency           not null,
    stripe_fee                 currency,
    seller_net                 currency           null,
    available_at               timestamptz        null,

    -- New field to store failure details (replaces checkout_failure table)
    failure_details            jsonb,

    created_at                 timestamptz        not null default now(),
    updated_at                 timestamptz        not null default now(),

    primary key (checkout_id, seller_id)
);

comment on table transaction is $$
    Represents a transaction between a buyer and seller for a specific checkout.
    A checkout can have multiple transactions (one per seller).
    
    This table combines the old payment and checkout_failure tables.
    Failed transactions have status starting with 'failed_' and details in failure_details column.
$$;

comment on column transaction.actual_shipping_cost is $$
    The actual shipping cost that the platform pays to Shippo for this order.
    This may differ from shipping_subtotal when free shipping is offered to buyers.
    Used to calculate the correct application fee for the platform.
$$;

comment on column transaction.seller_net is $$
    Amount the seller receives after all Miniswap and Stripe fees (payment processing, currency conversion, etc) have been deducted.
    This is in the seller's local currency.

    Note that this value is computed asynchronously by Stripe, and will be null when the transaction is first processed.
$$;

comment on column transaction.available_at is $$
    Timestamp when the `seller_net` will become `available` for payout in the seller's stripe balance.
$$;

comment on column transaction.failure_details is $$
    JSON details about why a transaction failed. Structure depends on failure type.
    Only populated when status starts with 'failed_'.
$$;

create index idx_transaction_checkout_seller_status on transaction (checkout_id, seller_id, status);

create type tracking_status as enum (
    'pre_transit',
    'transit',
    'delivered',
    'returned',
    'failure',
    'unknown'
    );


create type tracking_substatus as enum (
    'information_received',
    'address_issue',
    'contact_carrier',
    'delayed',
    'delivery_attempted',
    'delivery_rescheduled',
    'delivery_scheduled',
    'location_inaccessible',
    'notice_left',
    'out_for_delivery',
    'package_accepted',
    'package_arrived',
    'package_damaged',
    'package_departed',
    'package_forwarded',
    'package_held',
    'package_processed',
    'package_processing',
    'pickup_available',
    'reschedule_delivery',
    'delivered',
    'return_to_sender',
    'package_unclaimed',
    'package_undeliverable',
    'package_disposed',
    'package_lost',
    'other'
    );

create type shippo_transaction_status as enum (
    'waiting', 'queued', 'success', 'error', 'refunded', 'refund_pending', 'refund_rejected'
    );

create table shipment (
    parcel_id             int references parcel primary key,

    checkout_id           int references checkout   not null,
    seller_id             int references seller     not null,

    shippo_transaction_id shippo_transaction_id     not null unique,
    shippo_selected_rate  shippo_rate_id            not null unique,
    shippo_status         shippo_transaction_status not null,
    shippo_label_url      url                       not null,

    tracking_number       text                      not null,
    tracking_url_provider text                      not null,

    must_ship_by          timestamptz               not null default now() + interval '4 days',

    created_at            timestamptz               not null default now(),
    updated_at            timestamptz               not null default now(),

    -- Ensures that shipments must be created AFTER the transaction is processed
    foreign key (checkout_id, seller_id) references transaction (checkout_id, seller_id)
);

comment on table shipment is $$
    A shipment corresponds to a shippo transaction, i.e. a purchased shipping label.
$$;

create table tracking_update (
    tracking_update_id    int generated by default as identity primary key,
    shippo_transaction_id shippo_transaction_id not null references shipment (shippo_transaction_id) on delete cascade,

    eta                   timestamptz,
    messages              text[]                not null default array []::text[],
    status                tracking_status       not null,
    status_details        text                  not null,
    status_date           timestamptz           not null,

    substatus_code        tracking_substatus    not null,
    substatus_message     text                  not null,
    action_required       bool                  not null,

    city                  text                  not null,
    state                 text,
    zip                   text                  not null,
    country               text                  not null,

    created_at            timestamptz           not null default now(),

    unique (shippo_transaction_id, status, substatus_code, status_date)
);

comment on table tracking_update is $$
References:
- https://docs.goshippo.com/docs/tracking/tracking/
- https://docs.goshippo.com/shippoapi/public-api/#tag/Tracking-Status
$$;

create domain stripe_refund_id as text;

create type refund_status as enum (
    'queued',
    'pending',
    'succeeded',
    'failed',
    'requires_action',
    'canceled'
    );

create type shipment_cancellation_reason as enum (
    'buyer_requested',
    'seller_requested',
    'seller_disabled',
    'payment_intent_canceled'
    );

create type shipment_cancellation_status as enum (
    'pending', -- Initial state, waiting for label refund
    'label_refunded', -- Shippo label has been refunded
    'payment_canceled' -- Stripe payment has been canceled
    );

create table shipment_cancellation (
    shippo_transaction_id shippo_transaction_id        not null references shipment (shippo_transaction_id) on delete cascade primary key,
    reason                shipment_cancellation_reason not null,
    status                shipment_cancellation_status not null default 'pending',

    created_at            timestamptz                  not null default now(),
    updated_at            timestamptz                  not null default now()
);

comment on table shipment_cancellation is $$
    Shipment cancellation can occur after purchase but before the shipment has been dispatched when:
    - The buyer requests to cancel
    - The seller requests to cancel
    - The seller failed to ship the parcel in the window allotted

    Note that a purchase from one seller can include multiple shipments. So if a buyer requests to cancel an order from a seller,
    each individual shipment within that order must be canceled separately.

    Let's say an order from one seller included two shipments, and the seller ships one but fails to ship the other.
    That is why we need to cancel each shipment individually.

    Note that the shippo refund status can be seen in the `shipment` table's `shippo_status` column.
$$;


create type dispute_kind as enum (
    'not_as_described',
    'damaged_in_transit'
    );


create table dispute (
    payment_intent_id payment_intent_id not null references transaction (payment_intent_id) primary key,
    kind              dispute_kind      not null,
    details           text              not null
        constraint details_not_empty check (trim(details) <> ''),

    admin_notes       text,

    created_at        timestamptz       not null default now(),
    updated_at        timestamptz       not null default now()
);


create table refund (
    refund_id         int generated by default as identity primary key,
    payment_intent_id payment_intent_id references dispute not null,

    stripe_refund_id  stripe_refund_id                     null unique,
    refund_status     refund_status                        not null default 'queued',

    amount            currency                             not null
        constraint refund_amount_gt_zero check ((amount).amount > 0),
    include_shipping  bool                                 not null default false,

    reason            text                                 not null
        constraint refund_reason_not_empty check (trim(reason) <> ''),

    created_at        timestamptz                          not null default now(),
    updated_at        timestamptz                          not null default now(),

    constraint stripe_refund_id_required check (
        refund_status = 'queued'
            or stripe_refund_id is not null
        )
);

create unique index one_shipping_refund_per_payment
    on refund (payment_intent_id)
    where include_shipping;

comment on table refund is $$
    (Partial) refund of a purchase. Refunds are not necessarily attached to a return.
    Multiple refunds can be issued for the same purchase as long as the total amount refunded is <= the purchase amount.


    Refunds can only be created after the payment has been captured.
$$;

comment on column refund.include_shipping is $$
    Whether to refund the buyer's original shipping costs.
    Only one refund for a given payment can refund the buyer's shipping costs.
$$;