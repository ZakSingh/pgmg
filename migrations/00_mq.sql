create schema mq;

create type mq.event_type as enum (
    -- Miniswap events
    'pending_registration.created',
    'password_reset.requested',
    'account.created',

    'checkout.failed',

    'transaction.pending',
    'transaction.method_attached',
    'transaction.intent_created',
    'transaction.ready_for_capture',
    'transaction.succeeded',
    'transaction.failed',
    'transaction.canceled',

    'shipment.created',
    'shipment.in_transit',
    'shipment.canceled',
    'shipment.delivered',
    'shipment.expired',

    'shipment_cancellation.created',
    'shipment_cancellation.label_refunded',
    'shipment_cancellation.payment_canceled',

    'refund.succeeded',

    -- Shippo webhook events
    'shippo.transaction.created',
    'shippo.transaction.updated',
    'shippo.track.updated',

    -- Stripe platform account events
    'sp.setup_intent.succeeded',
    'sp.customer.created',

    -- Stripe connect webhook events
    'sc.account.updated',
    'sc.payment_intent.created',
    'sc.payment_intent.succeeded',
    'sc.payment_intent.payment_failed',
    'sc.payment_intent.amount_capturable_updated',
    'sc.payment_intent.canceled',
    'sc.refund.created',
    'sc.application_fee.refunded',
    'sc.charge.updated',
    'sc.payout.created',
    'sc.payout.paid',
    'sc.payout.failed',

    -- Commands
    'exchange_rates.refresh',
    'scrape_miniset.start'
    );

create table mq.event (
    event_id   bigint generated by default as identity primary key,
    event_type mq.event_type not null,
    payload    jsonb         not null default '{}'::jsonb,
    created_at timestamptz   not null default now()
);

comment on table mq.event is 'Raw event stream.';

create table mq.subscription (
    subscriber_name text          not null primary key,

    event_type      mq.event_type not null,
    is_active       boolean       not null default true,
    max_attempts    smallint      not null default 1,

    created_at      timestamptz   not null default now(),
    updated_at      timestamptz   not null default now()
);

comment on table mq.subscription is 'Registers a listener for a specific event type.';
comment on column mq.subscription.subscriber_name is 'Each listener can only subscribe to one event type.';
comment on column mq.subscription.is_active is 'If false, the listener will not receive any events.';

create table mq.delivery (
    event_id        bigint      not null references mq.event,
    subscriber_name text        not null references mq.subscription,
    succeeded_at    timestamptz null,
    attempt         smallint    not null default 0,
    available_at    timestamptz not null default now(),
    created_at      timestamptz not null default now()
);

comment on table mq.delivery is 'Records an attempt to deliver a message to a listener.';

create index idx_mq_delivery_event_id on mq.delivery (event_id);
create index idx_mq_delivery_subscriber_name on mq.delivery (subscriber_name);

create or replace function mq.fanout_event() returns trigger
    language plpgsql as $$
begin
    insert into mq.delivery (event_id, subscriber_name)
    select new.event_id, s.subscriber_name
    from mq.subscription s
    where s.event_type = new.event_type
      and s.is_active;
    return new;
end;
$$;

comment on function mq.fanout_event() is $$
    Fanout an event to all active subscribers.
$$;

create trigger trg_fanout
    after insert
    on mq.event
    for each row
execute function mq.fanout_event();

